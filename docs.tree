TODO
finish reading Interaction Graphs
how the fuck is it homoiconic
	what do is even???
	what is via what isnt
how do functors work
fix how i confused closure and environment
internalization
	glyph and rune editor
		git compatability
			use txt instead of png
			for serialization of boundaries
			serialization of world still uses png for
				maybe this is not good?
				view within alk instead of from image editor
				this will cause editor-editor issues
	rune-example creation capability
what exactly is is the boundary between
	program:process:thread:function:invocation


metadoc grammar
	lazy tree notation
	see cheesecake.txt for example of howto this
	minimal sentences

paradigms
	type
		strong implicit with generics, haskell style
		homoiconic functor macros
		uses python-type until py subsumed
	evaluation order
		sequential, greedy
		no operator precedence
			trivial inversion
	memory
		container-based heap
		allow the graph to determine lifecycle via scope
	mutability
		python-style, for now
			allow the host lang to determine behavior where trivial
			simple for both engineering and intuitiion
	async
		polling loop, manual, no inversion of control
		high priority threads are isolated, use locked queues for io
	concurrency
		container based SIMD warp
		fences and atomics eschewed with doublebuffer and gather builtins

intermediate forms
	compilation happens live within editor
	phase0
		implicit behaviors, errors, warnings, evaluated while typing
	phase1
		macro evaluation
	phase2
		phase0 repeated after macro output

namespaces, symbols strictly may not overlap
case sensitive
tokens
	what are visible to the user and what is parsed
	kinds, determined by namemap

		variables
			python style values
			containers
				allocation done via denotated methods

		literals
			numeric types, c style
			tensors, glsl style, row major
			strings as builtin string-type container

		functions
			haskell style signature
				allow static type and generics
			env
				args, rets, and throws; are defined via a dict, where they override other environment
				the environment dict must be macro-scope
					no runtime function generation

				API is defined with an interface-lock, causing dict changes to error until cleared
				C ABI generated as
					err_t f(struct{...} args, struct{...} ret);
				FFI is defined with a signature-lock, which is an interface-lock that additionally disables generics

				methods are builtin macros for generated environments
			functors
				defined at macro-level
		conversions
			implicit type conversions
			may be called explicitly, or are scanned for upon type mismatch
			builtin macro that generates a function named after the morphism
			the generated functions are putted into a global static conversion dict

			conversions may be generated by, but not used by macros
				prevents complexity for both compiler and user

			conversions may only reside in the global environment
				scoped implicit behavior may be dangerous
				may be changed later

			litany application, see litany doc

		types
			idfk just containers and c structs i guess
			python-embedded for now

serialization
	glyph grids are stored as text files
	first example being fonts
	is friendly towards git
		glyphs should be arranged vertically when possible
		to reduce line width
	boundaries are each their own set of lines

trexpr tree expression
	trivially convertable to lisp


litany
	combinator methodology
		obviates infix-postfix-prefix and arity problems
	operates only on variables, literals, and morphisms
		currently cannot be used for types
	converted into trexpr via dualstack inference
	dual stack inference
		1d sequence of tokens -> token-kind, symbol
		foreach symbol in litany, determine its namespace
			morphs attempt consuming the stack
				for any overload
				if the stack does not contain the correct arg types in the correct positions
					the morph is pushed onto the morphic stack
			variables are pushed onto the stack
				the morphic stack is then peeked in order to attempt consuming the stack
					if a morph is matched
						it is removed from the morphic stack
						the return values are pushed to the stack
						recurse morphic stack poking until none match
		the tree output is an immediate display
			this makes the implicit behavior observable


intoned input
	hummed frequencies used as modifer keys
	as how fighter pilots convey magnitude
	used mostly for curve editing, or any multidimensional artistic adjustor
	ie blender using shift for fine adjustment


IDE
	editor for literals including curves and fields
	inline container and field visualizers
		attach as macros, where the macro may have its ranges transformed with range functions
		autorange chooses best contrast from: linear/log/exponential, (un)normalized
		types
			traditional debugger
			R1->Rn: cartesian graph, where n is palette-mapped
			R2->R(1-3) image
			R3->R(1-3) volumetric scattering, solid voxels, slices
			todo: higher dimensions may always be sliced

	analyzers
		cyclomatic, generic usecount, macro usecount
		reference visualizer
		coupling visualizer
		stack depth
		container copying
	testing
		autofuzzer
